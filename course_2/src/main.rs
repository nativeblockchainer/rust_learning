fn main() {
    // occur_move();
    let s1 = String::from("I am a superman.");
    let s2 = &s1;
    let s3 = &&&&&s1;
    let s4 = &s2;
    let s5 = s2;
    println!("{s1}");
    println!("{s2}");
    println!("{s3}");
    println!("{s4}");
    println!("{s5}");
}

/**
 * 1、变量发生了move，
 * 后面再使用该变量会出现编译错误，该变量后面已经无法访问，要么使用clone()
 */
fn occur_move() {
    let s1 = String::from("I am a superman.");
    let s2 = s1;
    // let s2 = s1.clone();
    // println!("{s1}");
    println!("{s2}");
}

/**
 * ● Rust中，每一个值（资源）都有一个所有者；
 * ● 任何一个时刻，一个值只有一个所有者；
 * ● 当所有者所在作用域结束的时候，值会被释放掉。
  * 默认做复制操作的有：
  * ● 所有的整数类型，比如u32,
  * ● 布尔类型，bool
  * ● 浮点数类型：f32, f64
  * ● 字符类型 char
  * ● 由以上类型组成的元组类型 Tuple，如（i32, i32, char）
  * 其它类型，默认都是做值的移动操作。
  */
fn a() {
    trait

}

/**
 * 1、值发生了move，后面再使用该变量会出现编译错误，该变量后面已经无法访问，要么使用clone()，使用clone()需要实现Clone Trait。
 * 2、每一个值（资源）都有一个所有者，任何一个时刻，一个值只有一个所有者。
 * 3、当所有者所在作用域结束的时候，值会被释放掉。
 * 4、一个拥有所有权的值的作用域是从它定义时到花括号结束。
 * 5、引用的作用域是从它定义到它最后一次使用时结束。
 * 6、引用（不可变引用和可变引用都是）变量的作用域不会长于所有权变量的作用域。肯定的，不然就会出现悬锤引用了，这是典型的内存安全问题。Rust中的引用必定是有效的。
 * 7、一个资源的可变引用与不可变引用的作用域不能交叠（overlap），也可以说不能同时存在。
 * 8、某个时刻对某个资源只能存在一个可变引用，不能有超过一个可变引用同时存在。
 * 9、一个资源的不可变引用，可以同时存在多个。
 * 10、不可变引用可以被复制。
 * 11、可变引用不能被复制，只能被move。
 */

